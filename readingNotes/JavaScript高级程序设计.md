# JavaScript高级程序设计(第三版)

## 前言
最近研究了很多流行的框架angularJS、React，也开始运用npm来管理项目，优化代码……

虽然正在追赶不断发展的前端脚步，知识在不断膨胀，但是半路出家的我，感觉追的越来越艰难了。

所以决定暂时放下手上正在研究的众多时髦的框架，回来再补一遍JS基础，当然选的还是这本《JavaScript高级程序设计》，原因大家应该都懂。同时做一点小笔记，当然不会太详细，毕竟我本身也是一个懒人_(:з」∠)_

***
## 1 JS简介

## 2 在html中使用JS

```html
<!DOCTYPE html>
<html>
    <head>
        <title>Example HTML Page</title>
    </head>
    <body>
        <!-- 这里放内容 -->
        <script defer="defer" src="example1.js"></script>
        <script async src="example2.js"></script>
    </body>
</html>
```

script标签属性defer和async只适用于外部脚本：defer表示延迟，async表示异步

***

## 3 基本概念

### 3.1 语法（严格模式）
ECMAScript5引入了严格模式(strict mode)的概念。在严格模式下，ECMAScript3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：

```javascript
'use strict';
```

### 3.2 关键字保留字（略）

### 3.3 变量声明
**使用`var`操作符定义的变量，将成为定义该变量的作用域中的局部变量。**

如果在函数中使用`var`定义一个变量，那么这个变量在函数退出后就会被销毁，例如：

```javascript
function test () {
    var message = 'hi'; //局部变量
}
test();
alert(message); //错误！
```

如果省略`var`操作符，message就成了全局变量。这样，只要调用过一次`test()`函 数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。但不推荐，导致变量难维护。

给未经声明的变量赋住在**严格模式** 下会抛出**ReferenceError**错误。

### 3.4 数据类型
* undefined
    * 在使用`var`声明变量但未对其加以初始化时
* null
    * 特殊的object对象
    * 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null
* boolean
    * 可以对任何数据类型的值调用`Boolean()`函数,返回的值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。

        | 数据类型 | 转换为true的值 | 转换为false的值 |
        |:------:|:------:|:------:|
        | Boolean | true | false |
        | String | 任何非空字符串 | 空字符串 |
        | Number | 任何非零数字（包括无穷大） | 0和NaN |
        | Object | 任何对象 | null |
        | Undefined | n/a | undefined |
* number
    * 浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.300000000000000004
    * `parseInt()`
        * 为了消除在使用`parseInt()`函数时可能导致的困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）
        * 多数情况下，我们要解析的都是十进制数，因此始终将**10**作为第二个参数是非常必要的
* string
* object
    * Object的每个实例都具有下列属性和方法:
        * `Constructor`: 保存着用于创建当前对象的函数。
        * `hasOwnProperty(propertyName)`: 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：`o.hasOwnProperty('name')`）。
        * `isPrototypeOf(object)`: 用于检查传入的对象是否是另一个对象的原型
        * `propertyIsEnumerable(propertyName)`: 用于检查给定的属性是否能够使用for-in语句来枚举，与`hasOwnProperty()`方法一样，作为参数的属性名必须以字符串形式指定。
        * `toLocaleString()`: 返回对象的字符串表示，该字符串与执行环境的地区对应
        * `toString()`: 返回对象的字符串表示
        * `valueOf()`: 返回对象的字符串、数值或布尔值表示。通常与`toString()`方法的返回值相同。

### 3.5 操作符
#### 3.5.1 一元操作符（略）
#### 3.5.2 位操作符
* ECMAScript中的所有数值都以IEEE-954 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。
* 按位非(NOT)
    * 按位非操作符由一个波浪钱`~`表示，执行按位非的结果就是返回数值的反码。

        ```javascript
        var num1 = 25;    //二进制00000000000000000000000000011001
        var num2 = ~num1; //二进制11111111111111111111111111100110
        alert(num2);      //-26
        ```

* 按位与(AND)
    * 按位与操作符由一个和号字符`&`表示，它有两个操作符数 。从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作：按位与操作只在两个数值的对应位都是1时才返回1

        | 第一个数值的位 | 第二个数值的位 | 结果 |
        |:------:|:------:|:------:|
        | 1 | 1 | 1 |
        | 1 | 0 | 0 |
        | 0 | 1 | 0 |
        | 0 | 0 | 0 |

        ```javascript
        var result = 25 & 3;
        alert(result); //1
        ```

* 按位或(OR)
    * 按位或操作符由一个坚线符号`|`表示，同样也有两个操作数,按位或操作在有一个位是1的情况下就返回1

        | 第一个数值的位 | 第二个数值的位 | 结果 |
        |:------:|:------:|:------:|
        | 1 | 1 | 1 |
        | 1 | 0 | 1 |
        | 0 | 1 | 1 |
        | 0 | 0 | 0 |

* 按位异或（XOR）
    * 按位异或操作符由一个插入符号`^`表示，也有两个操作数，以下是按位异或的真值表。

        | 第一个数值的位 | 第二个数值的位 | 结果 |
        |:------:|:------:|:------:|
        | 1 | 1 | 0 |
        | 1 | 0 | 1 |
        | 0 | 1 | 1 |
        | 0 | 0 | 0 |

* 左移
    * 左移操作符由两个小于号`<<`表示，这个操作符会将数值的所有位向左移动指定的位数。

        ```javascript
        var oldValue = 2;                //等于二进制的10
        var newValue = oldValue << 5;    //等于二进制的1000000，十进制的64
        ```

* 有符号的右移
    * 有符号的右移操作符由两个大于号`>>`表示，这个操作符会将数值向右移动，但保留符号位(即正负号标记)，有符号的右移操作与左移操作恰好相反。

* 无符号的右移
    * 无符号的右移操作符由3个大于号`>>>`表示，这个操作符会将数值的所有32位都向右移动
    * 对正数来说，无符号的右移的结果与有符号的右移相同
    * 对负数来说，结果相差非常大

#### 3.5.3 布尔操作符
* 逻辑非
    * 逻辑非操作符由一个叹号`!`表示，可以应用于ECMAScript中的任何值。
    * 逻辑非操作符遵循下列规则：
        * 如果操作数是一个对象，返回false
        * 如果操作数是一个空字符串，返回true
        * 如果操作数是一个非空字符串，返回false
        * 如果操作数是数值0，返回true
        * 如果操作数是任意非0数值(包括Infinity)，返回false
        * 如果操作数是null，返回true
        * 如果操作数是NaN，返回true
        * 如果操作数是undefined，返回true
* 逻辑与
    * 逻辑与操作符由两个和号`&&`表示，有两个操作数，逻辑与的真值表如下：

        | 第一个操作数 | 第二个操作数 | 结果 |
        |:------:|:------:|:------:|
        | true | true | true |
        | true | false | false |
        | false | true | false |
        | false | false | false |

    * 逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下， 逻辑与操作就不一定返回布尔值，此时，它遵循下列规则：
        * 如果第一个操作数是对象，则返回第二个操作数
        * 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象
        * 如果两个操作数都是对象，则返回第二个操作数
        * 如果有一个操作数是null，则返回null
        * 如果有一个操作数是NaN， 则返回NaN
        * 如果有一个操作数是undefined，则返回undefined
    * 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值
* 逻辑或
    * 逻辑或操作符由两个竖线符号`||`表示，有两个操作数，逻辑或的真值表如下：

        | 第一个操作数 | 第二个操作数 | 结果 |
        |:------:|:------:|:------:|
        | true | true | true |
        | true | false | true |
        | false | true | true |
        | false | false | false |

    * 如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值，此时，它遵循下列规则：
        * 如果第一个操作数是对象，则返回第一个操作数
        * 如果第一个操作数的求值结果为false，则返回第二个操作数
        * 如果两个操作数都是对象，则返回第一个操作数
        * 如果两个操作数都是null，则返回null
        * 如果两个操作数都是NaN， 则返回NaN
        * 如果两个操作数都是undefined，则返回undefined
    * 逻缉或操作符也是短路操作符，即第一个操作数的求值结果为true，就不会对第二个操作数求值

#### 3.5.4 乘性操作符（略）
#### 3.5.5 加性操作符（略）
#### 3.5.6 关系操作符（略）
#### 3.5.7 相等操作符
* 由于相等`==`和不相等`!=`操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等`===`和不全等`!==`操作符

#### 3.5.8 条件操作符

```
variable= boolean_express1on ? true_value : false_value
```

这行代码的含义就是基于对boolean_expression求值的结果，结果为true，则给变量variable赋true_value的值，如果求值结果为false,则给变量variable赋false_value值

#### 3.5.9 赋值操作符（略）
#### 3.5.10 逗号操作符
* 逗号操作符多用于声明多个变量
* 逗号操作符还可以用于赋值，逗号操作符总会返回表达式中的最后一项

    ```javascript
    var num1 = 1, num2 = 2, num3 = 3;
    var num = (5, 1, 4, 8, 0);  //num的值为0
    ```

### 3.6 语句
#### 3.6.1 if语句（略）
#### 3.6.2 do-while语句（略）
#### 3.6.3 while语句（略）
#### 3.6.4 for语句（略）
#### 3.6.5 for-in语句
* for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是for-in语句的语法：

    ```
    for (property in expression) statement
    ```

    ```javascript
    //使用for-in循环来显示BOM中window对象的所有属性
    for (var propName in window) {
    document.write(propName);
    }
    ```

* ECMAScript对象的属性没有顺序，通过for-in循环输出的属性名的顺序是不可预测的
* 如果表示要迭代的对象的变量值为null或undefined,for-in语句会抛出错误。ECMAScript5更正了这一行为：对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。
#### 3.6.6 label语句
* 使用label语句可以在代码中添加标签，以便将来使用。以下是label语句的语法：

    ```
    label: statement
    ```

* 定义的label语句可以在由break或continue语句引用
* 加标签的语句一般都与for语句等循环语句配合使用

#### 3.6.7 break和continue语句
* break和continue语句用于在循环中精确地控制代码的执行
    * break语句会立即退出循环，强制继续执行循环后面的语句
    * continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行
* break和continue语句和label语句联合使用

    ```javascript
    var num = 0;
    outermost: for (var i = 0; i < 10; i++) {
        for (var j = 0; j < 10; j++) {
            if (i == 5 && j == 5) {
                break outermost;
            }
            num++;
        }
    }
    alert(num);  //55
    ```

    在这个例子中， outermost标签表示外部的for语句。如果每个循环正常执行10次， 则num++语句就会正常执行100次。num的值应该是100。但内部循环中的break语句带了一个参数(要返回到的标签),添加这个标签的结果将导致break语句不仅会退出内部的for语句（即使用变量j的循环），而且也会退出外部的for语句（即使用变量i的循环）。为此，当变量i和j都等于5时，num的值正好是55。同样，continue语句也可以像这样与label语句联用。

* 联用break、continue和label语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。建议如果使用label语句，一定要使用**描述性**的标签，同时不要嵌套过多的循环。

#### 3.6.8 with语句
* 在开发大型应用程序时，不建议使用with语句。
#### 3.6.9 switch语句（略）

### 3.7 函数
* 返回值
    * 要么让函数始终都返回一个值，要么永远都不要返回值，否则会给调试代码带来不便
* 严格模式对函数有一些限制：
    * 不能把函数命名为eval或arguments
    * 不能把参数命名为eval或arguments
    * 不能出现两个命名参数同名的情况

## 4 变量、作用域和内存问题
### 4.1 基本类型和引用类型的值
* 5种基本数据类型（Undefined、Null、Boolean、Number、String）是按值访问的，可以操作保存在变量中的实际的值
* 引用类型的值是保存在内存中的对象，引用类型的值是按引目访问的，在操作对象时，实际上是在操作对象的引用而不是实际的对象
* 动态的属性
    * 可以给一个引用类型的值增加属性
    * 无法给基本类型的值添加属性
* 复制变量值
    * 从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到新变量的位置上，这两个变量可以参与任何操作而不会相互影响
    * 从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，这个值的副本实际上是一个指针，指向存储在堆中的同一个对象，改变一个变量，会影响到另一个变量
* 传递参数
    * ECMAScript中所有函数的参数都是按值传递的（把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样）
        * 向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数)
        * 向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部
* 检测类型
    * instanceof操作符，其语法如下所示：

        ```
        result = variable instanceof constructor
        ```

        如果变量是给定引用类型（根据它的原裂链来识别）的实例，那么 instanceof操作符就会返回true，例如：

        ```javascript
        alert(person instanceof Object);   //变量person是Object吗？
        alert(colors instanceof Array);    //变量colors是Array吗？
        alert(pattern instanceof RegExp);  //变量pattern是RegExp吗？
        ```

### 4.2 执行环境及作用域
### 4.3 垃圾收集






***


更新中……



