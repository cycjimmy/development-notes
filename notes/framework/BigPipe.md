# BigPipe

## 前端性能优化：理想的方案目标
* 单个数据源的相应时间不影响页面的onload时间
* 脚本和CSS的加载不阻塞页面的渲染
* 用户第一时间看到要展示的东西，可感知速度

### BigPipe是怎么做的？

在**一个请求**里**分割页面**为多个pagelet小块，然后**分段输出**到浏览器，前后端**并行处理**

#### 如何分块输出？
先说说chunked

* 让页面分块，逐步呈现
	* HTTP1.1的分块编码传输
	* 浏览器接收完一个完整的chunked就开始渲染
	* http头：Transfer-Encoding:chunked

#### 我们做到了什么？
* 在**一个请求**里完成输出
* 减少了**请求数量**
* 手动控制**分段输出**
* 服务器可控制**呈现顺序**
* 缩短了页面ready时间

#### 优势
* 单位时间内可以处理更多请求
* 需要维持的连接数变少
* 用户能第一时间看到首屏的数据
* 感知到是速度最快的那个模块

***

### 脚本阻塞页面的问题如何解决？
* 页面中JS和CSS会阻塞页面的渲染(原因)
	* 脚本过大，加载时间长
	* 代码没写好，脚本执行时间过长
* 解决脚本阻塞：**只在头部输出一段最简脚本，其他JS/CSS都在domready之后加载**
	* 保证无脚本阻塞，可快速的domready
	* 保证页面框架内容的快速展示

#### 这种解决方法有什么问题？
1. 增加了大量JS/CSS的请求数
2. IE下的各种坑
	* 文档中只有前31个link和style有用
	* 每个CSS或style中的选择符个数不能超过4095
3. 现在网络带宽已经很不错了，脚本文件不是很大的情况下真没必要异步加载，链接的建立成本比传输成本高
4. 初始化时模块内代码可先不执行，减少代码执行时间

***

### 实践中遇到的问题

1. 与nginx配合输出

	> nginx本身是有缓冲区的，输出到浏览器的chunked会被nginx合并输出

	* 解决方法：
		* 返回头里设置header: X-Accel-Buffering: nores.set('X-Accel-Buffering', 'no')


2. IE6不支持chunked

	> IE6不支持http1.1，也就不支持chunked

	* 解决方法：
		* BigPipe输出的页面在IE6下是可以执行的，只是不支持分块输出的加载方式
		* 判断如果是IE6就不设置X-Accel-Buffering，让nginx帮我们缓冲输出


3. 并行任务调度
	
	> 长时间未结束的任务会拖慢服务器的性能，
	> 后台任务执行时可能浏览器已经断开连接
	
	* 解决方法：
		* 指定每个任务的超时时间
		* 连接断开后会发送不成功，设置标记，在任务的关键点检查，提前结束任务


4. 对搜索引擎支持不好

	> 页面HTML都是动态插入进去的
	
	* 解决方法：
		* 对搜索引擎返回特殊的页面
		* 等着搜索引擎更加智能

***

### BigPipe适用场景

> BigPipe仅适用于页面区块多，但又互相独立，需要读取多个数据源的场景。